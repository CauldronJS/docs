(window.webpackJsonp=window.webpackJsonp||[]).push([[9],{120:function(e,n,t){"use strict";t.d(n,"a",(function(){return p})),t.d(n,"b",(function(){return m}));var o=t(0),a=t.n(o);function r(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function i(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);n&&(o=o.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,o)}return t}function l(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?i(Object(t),!0).forEach((function(n){r(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):i(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function c(e,n){if(null==e)return{};var t,o,a=function(e,n){if(null==e)return{};var t,o,a={},r=Object.keys(e);for(o=0;o<r.length;o++)t=r[o],n.indexOf(t)>=0||(a[t]=e[t]);return a}(e,n);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(o=0;o<r.length;o++)t=r[o],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(a[t]=e[t])}return a}var s=a.a.createContext({}),u=function(e){var n=a.a.useContext(s),t=n;return e&&(t="function"==typeof e?e(n):l({},n,{},e)),t},p=function(e){var n=u(e.components);return a.a.createElement(s.Provider,{value:n},e.children)},b={inlineCode:"code",wrapper:function(e){var n=e.children;return a.a.createElement(a.a.Fragment,{},n)}},d=Object(o.forwardRef)((function(e,n){var t=e.components,o=e.mdxType,r=e.originalType,i=e.parentName,s=c(e,["components","mdxType","originalType","parentName"]),p=u(t),d=o,m=p["".concat(i,".").concat(d)]||p[d]||b[d]||r;return t?a.a.createElement(m,l({ref:n},s,{components:t})):a.a.createElement(m,l({ref:n},s))}));function m(e,n){var t=arguments,o=n&&n.mdxType;if("string"==typeof e||o){var r=t.length,i=new Array(r);i[0]=d;var l={};for(var c in n)hasOwnProperty.call(n,c)&&(l[c]=n[c]);l.originalType=e,l.mdxType="string"==typeof e?e:o,i[1]=l;for(var s=2;s<r;s++)i[s]=t[s];return a.a.createElement.apply(null,i)}return a.a.createElement.apply(null,t)}d.displayName="MDXCreateElement"},99:function(e,n,t){"use strict";t.r(n),t.d(n,"frontMatter",(function(){return i})),t.d(n,"metadata",(function(){return l})),t.d(n,"rightToc",(function(){return c})),t.d(n,"default",(function(){return u}));var o=t(1),a=t(6),r=(t(0),t(120)),i={id:"jsx",title:"Using JSX In Cauldron",sidebar_label:"JSX"},l={id:"jsx",title:"Using JSX In Cauldron",description:"If you aren't familiar with JSX, check out [the documentation on the React docs](https://reactjs.org/docs/introducing-jsx.html). It allows us to create single-life objects with an easy and fluent syntax that doesn't clutter our codebase. If you look back at creating a command, you'll remember we had a bunch of options in our configuration that quickly made the creation unorganized and somewhat unmaintainable. Allowing Cauldron to use JSX solves some of those problems, but we can't use a library like React because it's made for UI.\r",source:"@site/docs\\jsx.md",permalink:"/docs/jsx",editUrl:"https://github.com/CauldronJS/scripts/edit/master/docusaurus/docs/jsx.md",sidebar_label:"JSX",sidebar:"someSidebar",previous:{title:"Making Our First Plugin",permalink:"/docs/making-our-first-plugin"},next:{title:"API Overview",permalink:"/docs/api-overview"}},c=[{value:"Introducing Rinse",id:"introducing-rinse",children:[]},{value:"Building Your Own Components",id:"building-your-own-components",children:[]}],s={rightToc:c};function u(e){var n=e.components,t=Object(a.a)(e,["components"]);return Object(r.b)("wrapper",Object(o.a)({},s,t,{components:n,mdxType:"MDXLayout"}),Object(r.b)("p",null,"If you aren't familiar with JSX, check out ",Object(r.b)("a",Object(o.a)({parentName:"p"},{href:"https://reactjs.org/docs/introducing-jsx.html"}),"the documentation on the React docs"),". It allows us to create single-life objects with an easy and fluent syntax that doesn't clutter our codebase. If you look back at creating a command, you'll remember we had a bunch of options in our configuration that quickly made the creation unorganized and somewhat unmaintainable. Allowing Cauldron to use JSX solves some of those problems, but we can't use a library like React because it's made for UI."),Object(r.b)("h2",{id:"introducing-rinse"},"Introducing Rinse"),Object(r.b)("p",null,"Rinse is hand made for Cauldron and builds off of what is compiled by the Babel plugin. Before using Rinse though, a little configuration has to be done."),Object(r.b)("p",null,"Check your ",Object(r.b)("inlineCode",{parentName:"p"},"deps")," directory for ",Object(r.b)("inlineCode",{parentName:"p"},"@cauldron/rinse"),". If it exists, awesome. If not, download it from the scripts repository. Once it's in there, run the command ",Object(r.b)("inlineCode",{parentName:"p"},"babel deps --out-dir node_modules --copy-files"),"."),Object(r.b)("p",null,"In your projects directory, create the file ",Object(r.b)("inlineCode",{parentName:"p"},"babel.config.js")," and put this in."),Object(r.b)("pre",null,Object(r.b)("code",Object(o.a)({parentName:"pre"},{className:"language-language/javascript"}),"module.exports = api => {\n  api.cache(true);\n  return {\n    plugins: [\n      '@babel/plugin-syntax-jsx',\n      [\n        '@babel/plugin-transform-react-jsx',\n        { pragma: 'Rinse.createComponent', pragmaFrag: 'Rinse.Fragment' }\n      ]\n    ]\n  }\n}\n")),Object(r.b)("p",null,"Now in your ",Object(r.b)("inlineCode",{parentName:"p"},"package.json"),", add the following to your dependencies:"),Object(r.b)("pre",null,Object(r.b)("code",Object(o.a)({parentName:"pre"},{}),'"@babel/cli": "^7.2.3",\n"@babel/core": "^7.3.4",\n"@babel/plugin-proposal-class-properties": "^7.4.0",\n"@babel/plugin-proposal-export-default-from": "^7.2.0",\n"@babel/plugin-proposal-object-rest-spread": "^7.4.3",\n"@babel/plugin-syntax-jsx": "^7.2.0",\n"@babel/plugin-transform-modules-commonjs": "^7.4.3",\n"@babel/plugin-transform-react-jsx": "^7.3.0",\n"@babel/preset-env": "^7.4.3",\n')),Object(r.b)("p",null,"Now create a new file ",Object(r.b)("inlineCode",{parentName:"p"},"./src/index.js"),"."),Object(r.b)("pre",null,Object(r.b)("code",Object(o.a)({parentName:"pre"},{}),"import Rinse, { Command } from '@cauldron/rinse';\n\nconst greet = ({sender}) => sender.sendMessage('Hello!');\n\nconst HelloCommand = () => (\n  <Command name=\"hello\" execute={greet} />\n);\n\nRinse.mount(<HelloCommand />);\n")),Object(r.b)("p",null,"Now run ",Object(r.b)("inlineCode",{parentName:"p"},"babel src --out-dir dist --copy-files")," and edit your ",Object(r.b)("inlineCode",{parentName:"p"},"package.json['main']")," to ",Object(r.b)("inlineCode",{parentName:"p"},"./dist/index.js"),"."),Object(r.b)("p",null,"When you reload the server, you should have a new command!"),Object(r.b)("h2",{id:"building-your-own-components"},"Building Your Own Components"),Object(r.b)("p",null,"Building a custom component is easy considering it's just a function call at the end of the day. If you explore what Babel compiled our code to, you'll see something like this:"),Object(r.b)("pre",null,Object(r.b)("code",Object(o.a)({parentName:"pre"},{className:"language-language/javascript"}),'const HelloCommand = () => _rinse.default.createComponent(_rinse.Command, {\n  name: "Hello",\n  execute: greet\n});\n')),Object(r.b)("p",null,"This tells us that technically we could call regular old ",Object(r.b)("inlineCode",{parentName:"p"},"HelloCommand()")," and it'd do the same thing. So the anatomy of a Rinse component is:"),Object(r.b)("pre",null,Object(r.b)("code",Object(o.a)({parentName:"pre"},{className:"language-language/javascript"}),"const MyComponent = props => {\n  // do whatever here\n  // finally return the children props. It can be null\n  return props.children;\n}\n")),Object(r.b)("p",null,"The ",Object(r.b)("inlineCode",{parentName:"p"},"props")," argument gives us every value that we used in the JSX component. In our hello command, props would look like this"),Object(r.b)("pre",null,Object(r.b)("code",Object(o.a)({parentName:"pre"},{}),"{\n  name: 'Hello',\n  execute: greet\n}\n")),Object(r.b)("p",null,"A barebones recreation of the ",Object(r.b)("inlineCode",{parentName:"p"},"Command")," component would look something like"),Object(r.b)("pre",null,Object(r.b)("code",Object(o.a)({parentName:"pre"},{className:"language-language/javascript"}),"const Command = props => {\n  cauldron.registerCommand(props.name, props);\n}\n")),Object(r.b)("p",null,"Easy, right? Now you don't have to worry about all these weird option objects! Use it to create a portals plugin, a faction component, or anything else. The list is pretty large!"))}u.isMDXComponent=!0}}]);